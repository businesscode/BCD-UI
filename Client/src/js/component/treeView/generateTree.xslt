<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2010-2017 BusinessCode GmbH, Germany

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!--
  This stylesheet groups a WRS by levels in order to create a tree view
  Grouping can follow 
    a) a @parentId attribute or if not given 
    b) the dimension columns
  Input: standard wrs:Wrs
  Params: number_of_levels, per default number od Columns/C with @dimId attribute.
  Output: Same Wrs but with <wrs:Level isVisible="" @rowCount=""/> elements between the rows for usage by treeView/rendering.xslt

  For a tree with n levels, it is assumed that the first n columns in the
  WRS are 'grouping' columns (similar to columns appearing in a SQL GROUP BY
  ... clause). Each column of these can have a @caption and an @order attribute

  To show data on non-leaf nodes (e.g., aggregation data), leave the other
  level columns empty.

  <Data xmlns="http://www.businesscode.de/schema/bcdui/wrs-1.0.0">
    <R id="1"><C>A</C><C></C><C></C>   <C>10</C></R>
    <R id="2"><C>A</C><C>K</C><C>X</C>  <C>7</C></R>
    <R id="3"><C>A</C><C>K</C><C>Y</C>  <C>3</C></R>
    ...

  The output is the input document with additional <wrs:Level> elements in it, like

  <Data xmlns="http://www.businesscode.de/schema/bcdui/wrs-1.0.0">
    <Level levelId="A" rowCount="1" isVisible="true">
      <R id="1">     <C>A</C>     <C/>     <C/> ... <C>10</C> </R> (Summary data 1. level)
      <Level levelId="A___K" rowCount="1" isVisible="false">   (NO summary data 2. level)
        <Level levelId="A___K_bcdLeaf" isLeaf="true" rowCount="3" isVisible="false">
          <R id="2"> <C>A</C> <C>K</C> <C>X</C> ... <C>7</C> </R>  (Leaf data)
          <R id="3"> <C>A</C> <C>K</C> <C>Y</C> ... <C>3</C> </R>
  ...

  Level/@levelId is unique and holds the dimension values separated by tree underscores,
  for leaves '___bcdLeaf' is appended. wrs:R/@id is identical to the original row's @id.
  Whether or not a non-leaf level element has a wrs:R child depends 
    a) parendId-case: always
    b) dim-case: whether an aggregate on that level exists.
  Only rows forming a clean tree are displayed. I.e. a break down will always be
  from level n to level n+1, for example:
  DE-empty-empty, DE-West-empty and DE-West-Cologne are included but
  DE-empty-Cologne is not.

  Note for dim-case: 'empty' columns are identified by string(wrs:C) = '', so please use
  <C></C>, <C><null/></C> or <C/>, do not use <C> </C> nor <C><null/> </C>.

  Implementation notes:
  Because we don't want to hardcode the number of levels, it is necessary to
  generate the grouping XSLT in a first step (at runtime). Afterwards, the
  dynamically generated XSLT is applied to the WRS. (This stylesheet is the
  generator.)
  The generated XSLT implements the hierachical Grouping Method presented
  in J. Tennison, "XSLT and XPath On The Edge", chap. 9.

  TODO: bcdEmpty
 -->
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xsla="http://www.w3.org/1999/XSL/Transform/Alias"
  xmlns:rnd="http://www.businesscode.de/schema/bcdui/renderer-1.0.0"
  xmlns:wrs="http://www.businesscode.de/schema/bcdui/wrs-1.0.0"
  xmlns:generator="urn(bcd-xsltGenerator)">

  <xsl:output method="xml" version="1.0" encoding="UTF-8" indent="no" media-type="text/xslt"/>

  <xsl:namespace-alias stylesheet-prefix="xsla" result-prefix="xsl"/>

  <!--
    (Integer) The number of levels (including leaves).
   -->
  <xsl:param name="number_of_levels" select="count(/*/wrs:Header/wrs:Columns/wrs:C[@dimId])"/>

  <xsl:variable name="treeTemplate" select="document('generateTreeTemplate.xslt')"/>

  <!-- If found, the parent/child hierarchy is derived from this information -->
  <xsl:variable name="parentChildColIdx" select="number(/*/wrs:Header/wrs:Columns/wrs:C[wrs:A[@id='parentId']]/@pos)"/>

  <xsl:template match="/">
    <xsl:comment> Generated by generateTree.xslt </xsl:comment>
    <xsl:apply-templates select="$treeTemplate/*" mode="generateXSLT"/>
  </xsl:template>

  <xsl:template match="generator:Group" mode="generateXSLT">
    <xsl:call-template name="generate_group">
      <xsl:with-param name="i" select="1"/>
      <xsl:with-param name="ckey" select="'wrs:C[1]'"/>
    </xsl:call-template>
  </xsl:template>

  <!-- Generate level i grouping -->
  <xsl:template name="generate_group">
    <xsl:param name="i"/>
    <xsl:param name="ckey"/>

    <xsl:variable name="new_ckey">concat(<xsl:value-of select="$ckey"/>, '___',
      wrs:C[<xsl:value-of select="($i + 1)"/>])</xsl:variable>

    <!-- Create a template for wrs:R, which orders by groups and inserts Level tags-->
    <xsl:element name="xsl:template" namespace="http://www.w3.org/1999/XSL/Transform">
      <xsl:attribute name="match">wrs:R</xsl:attribute>
      <xsl:attribute name="mode">group-<xsl:value-of select="$i"/></xsl:attribute>
      <xsla:param name="allAncestorsVisible"/>

      <xsl:element name="xsl:variable" namespace="http://www.w3.org/1999/XSL/Transform">
        <xsl:attribute name="name">k</xsl:attribute>
        <xsl:attribute name="select"><xsl:value-of select="$ckey"/></xsl:attribute>
      </xsl:element>

      <xsla:variable name="levelRows">
        <xsl:attribute name="select">key('level-<xsl:value-of select="$i"/>', $k)
          [concat(
            <xsl:call-template name="checkLowerDimsToBeEmpty">
              <xsl:with-param name="level" select="$i + 1"/>
            </xsl:call-template>
          ,'')='']
        </xsl:attribute>
      </xsla:variable>
      <xsla:variable name="guiStatus_expanded" select="$guiStatus/*/rnd:TreeView[@idRef = $bcdControllerVariableName]/rnd:Exp[. = $k]"/>
      <xsla:variable name="auto_expand" select="count(./wrs:Level) &lt; 2 and $enableAutoexpand = 'true'"/>
      <xsla:variable name="is_expanded" select="$guiStatus_expanded or $auto_expand or $autoExpandToLevel > count(ancestor-or-self::wrs:Level)"/>
      <wrs:Level>
        <xsl:attribute name="levelId">{$k}</xsl:attribute>
        <xsl:attribute name="order">{wrs:C[<xsl:value-of select="$i"/>]/@order}</xsl:attribute>
        <xsl:attribute name="isVisible">{$allAncestorsVisible}</xsl:attribute>
        <xsl:attribute name="rowCount">{count($levelRows)+boolean(count($levelRows)=0)}</xsl:attribute>
        <xsla:attribute name="caption">
          <xsla:choose>
            <xsla:when test="string(wrs:C[{$i}]/@caption)"><xsla:value-of select="wrs:C[{$i}]/@caption"/></xsla:when>
            <xsla:otherwise><xsla:value-of select="wrs:C[{$i}]"/></xsla:otherwise>
          </xsla:choose>
        </xsla:attribute>
        <xsla:copy-of select="wrs:C[{$i}]/@bcdTranslate"/>

        <!-- Create a non-leaf level -->
        <xsl:if test="$i &lt; $number_of_levels">
          <!-- Print the rows for this level. The key holds all rows having the right upper dimension values and
             we only want those where the dimension columns below our level are all empty.
             This does also mean rows where only a middle dimensions is blank, are never displayed -->
          <xsl:element name="xsl:apply-templates" namespace="http://www.w3.org/1999/XSL/Transform">
            <xsl:attribute name="select">$levelRows</xsl:attribute>
            <xsl:attribute name="mode">item</xsl:attribute>
            <xsla:with-param name="allAncestorsVisible" select="$allAncestorsVisible and $is_expanded"/>
          </xsl:element>
        </xsl:if>

        <!-- Create the next lower level (leaf or tree-node) -->
        <xsl:choose>
          <xsl:when test="$parentChildColIdx or $i &lt; $number_of_levels -1">
            <!-- Take care for the rows, being tree-descendants of the current context node -->
            <xsl:element name="xsl:apply-templates" namespace="http://www.w3.org/1999/XSL/Transform">
              <xsl:attribute name="select">
                key('level-<xsl:value-of select="$i"/>',$k) <!-- All descendants -->
                  [wrs:C[<xsl:value-of select="$i + 1"/>] != ''] <!-- Only those belonging to the next level (next level filled) -->
                  [count(. | key('level-<xsl:value-of select="$i + 1"/>',<xsl:value-of select="$new_ckey"/>)[1]) = 1] <!-- only one per distinct next level -->
              </xsl:attribute>
              <xsl:attribute name="mode">group-<xsl:value-of select="$i + 1"/></xsl:attribute>
              <xsla:with-param name="allAncestorsVisible" select="$allAncestorsVisible and $is_expanded"/>
            </xsl:element>
          </xsl:when>
          <xsl:when test="$i = $number_of_levels -1">
            <!-- Create the leaf level, i.e. the level where all dims are filled  -->
            <xsla:variable name="leafRows">
              <xsl:attribute name="select">key('level-<xsl:value-of select="$i"/>', $k) <!-- All descendants -->
                [wrs:C[<xsl:value-of select="$number_of_levels"/>]!=''] <!-- Only those belonging to the next level (next level filled), we assue, they are distinct -->
              </xsl:attribute>
            </xsla:variable>
            <wrs:Level>
              <xsl:attribute name="isVisible">{$is_expanded and $allAncestorsVisible}</xsl:attribute>
              <xsl:attribute name="rowCount">{count($leafRows)}</xsl:attribute>
              <xsl:attribute name="levelId">{$k}___bcdLeaf</xsl:attribute>
              <xsl:element name="xsl:apply-templates" namespace="http://www.w3.org/1999/XSL/Transform">
                <xsl:attribute name="select">$leafRows</xsl:attribute>
                <xsl:attribute name="mode">item</xsl:attribute>
              </xsl:element>
            </wrs:Level>
          </xsl:when>
        </xsl:choose>
      </wrs:Level>

    </xsl:element>

    <!-- Create a group template (like the one above), for each level -->
    <xsl:if test="$i &lt; $number_of_levels">
      <xsl:call-template name="generate_group">
        <xsl:with-param name="i" select="$i + 1"/>
        <xsl:with-param name="ckey" select="$new_ckey"/>
      </xsl:call-template>
    </xsl:if>

  </xsl:template>

  <!-- Helper concatenating all dimension columns below the current level -->
  <xsl:template name="checkLowerDimsToBeEmpty">
    <xsl:param name="level"/>
    wrs:C[<xsl:value-of select="$level"/>]
    <xsl:if test="$level &lt; $number_of_levels">
      <xsl:text>, </xsl:text>
      <xsl:call-template name="checkLowerDimsToBeEmpty">
        <xsl:with-param name="level" select="$level + 1"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>


  <xsl:template match="generator:Keys" mode="generateXSLT">
    <xsl:call-template name="generate_keys">
      <xsl:with-param name="i" select="1"/>
      <xsl:with-param name="ckey" select="'wrs:C[1]'"/>
    </xsl:call-template>

    <xsla:key name="childRows" match="/*/wrs:Data/wrs:R" use="wrs:C[{$parentChildColIdx}]/@parentId"/>
  </xsl:template>


  <!-- Create n keys, key is concatenated the dimension values separated by ___  -->
  <xsl:template name="generate_keys">
    <xsl:param name="i"/>
    <xsl:param name="ckey"/>

    <xsl:if test="$i &lt;= $number_of_levels">

      <xsl:element name="xsl:key" namespace="http://www.w3.org/1999/XSL/Transform">
        <xsl:attribute name="name">level-<xsl:value-of select="$i"/></xsl:attribute>
        <xsl:attribute name="match">wrs:R</xsl:attribute>
        <xsl:attribute name="use"><xsl:value-of select="$ckey"/></xsl:attribute>
      </xsl:element>

      <xsl:variable name="new_ckey">concat(<xsl:value-of select="$ckey"/>, '___', wrs:C[<xsl:value-of select="$i + 1"/>])</xsl:variable>

      <xsl:call-template name="generate_keys">
        <xsl:with-param name="i" select="$i + 1"/>
        <xsl:with-param name="ckey" select="$new_ckey"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <!-- Per default just copy -->
  <xsl:template match="node()|@*" mode="generateXSLT">
    <xsl:copy>
      <xsl:apply-templates select="node()|@*" mode="generateXSLT"/>
    </xsl:copy>
  </xsl:template>

</xsl:stylesheet>