/*
  Copyright 2010-2017 BusinessCode GmbH, Germany

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
package de.businesscode.bcdui.logging;

import java.sql.Timestamp;
import java.util.Collection;
import java.util.Date;

import de.businesscode.bcdui.toolbox.Configuration;
import de.businesscode.bcdui.toolbox.config.BareConfiguration;
import de.businesscode.bcdui.web.filters.RequestLifeCycleFilter;
import de.businesscode.sqlengine.SQLEngine;
import de.businesscode.util.SingletonHolder;
import de.businesscode.util.jdbc.wrapper.BcdSqlLogger;

/**
 * a singleton logger for SQL statements, the binding set used for it is bcd_log_sql,
 * record logged is {@link SqlToDatabaseLogger.LogRecord}
 * this class is not intended to be customized or extended in projects. The existence of
 * the binding-set enables this logger automatically.
 *
 * This logger used by BcdConnectionWrapper, so only wrapped JDBC connections log into database,
 * any connection obtained from {@link Configuration} class provides such a wrapped connection.
 *
 * If you want to disable logging temporarily, i.e. in case you're in another logger you may
 * want to use {@link #setLoggingEnabled(boolean)} method. Then, the SQLs generated by your code
 * might be propagated to Log4J logging, but they will not be published to the database. You may
 * also want to take a look at {@link BcdSqlLogger} class enabling programmatic switching of jdbc
 * logging.
 *
 * Additionally this logger currently also logs HTTP layer information, if available, provided
 * by {@link RequestLifeCycleFilter}, therefore the dependency on that class.
 *
 */
final public class SqlToDatabaseLogger extends ASqlLogger<SqlToDatabaseLogger.LogRecord>{
  private static final int DEFAULT_QUEUE_SIZE =       1000;
  private static final long DEFAULT_QUEUE_SLEEP_MS =  10*1000;  //10seconds
  private static final String PARAM_QUEUE_SIZE =      "bcdui/loggers/db/sql/queueSize";
  private static final String PARAM_QUEUE_SLEEP_MS =  "bcdui/loggers/db/sql/queueSleepMs";

  private static final ThreadLocal<Boolean> isDisabled = new ThreadLocal<Boolean>();

  @Override
  public boolean isEnabled() {
    Boolean ref = isDisabled.get();
    if(ref != null && ref){
      return false;
    } else return super.isEnabled();
  }

  /**
   * enables/disables JDBC logging for this thread, this method has to be called prior creating a JDBC statement
   * (or connection, datasource), if you dont obtain DataSource or Connection object from {@link Configuration}
   * class, you dont need to use this method, as those Connections are not logged anyway.
   *
   * sample usage:
   *
   * <pre>
   * try{
   *  SqlToDatabaseLogger.setLoggingEnabled(false);
   *
   *  ;; // obtain and work with JDBC statement here
   *
   * }finally{
   *  SqlToDatabaseLogger.setLoggingEnabled(true);
   * }
   * </pre>
   *
   * @param isEnabled
   */
  public synchronized void setEnabled(boolean isEnabled) {
    if (isEnabled) {
      isDisabled.remove();
    } else {
      isDisabled.set(Boolean.TRUE);
    }
  }

  /**
   * a shortcut to <code>getInstance().setEnabled()</code>
   * @param isEnabled
   */
  public static void setLoggingEnabled(boolean isEnabled){
    getInstance().setEnabled(isEnabled);
  }

  /**
   * record being logged into db
   */
  public static final class LogRecord extends LogEventBase {
    final private String jdbcMethod;
    final private String sql;
    final Date stamp = new Date();
    private long durationMs;
    private Integer rowsAffected;
    private String sessionId;
    private String pageHash, requestHash;

    public LogRecord(String jdbcMethod, String sql) {
      super();
      this.jdbcMethod = jdbcMethod;
      this.sql = sql;
    }

    public void setDurationMs(long durationMs) {
      this.durationMs = durationMs;
    }

    public void setRowsAffected(Integer rowsAffected) {
      this.rowsAffected = rowsAffected;
    }

    public void setSessionId(String sessionId) {
      this.sessionId = sessionId;
    }

    public void setPageHash(String pageHash) {
      this.pageHash = pageHash;
    }

    public void setRequestHash(String requestHash) {
      this.requestHash = requestHash;
    }

    @Override
    public String getFormattedMessage() {
      // just to have something here
      // previously, this method did not exists and LogRecord was stringified using regular toString() method, which sometimes swallowed information
      String s = toString(); // if only the class + instance is returned, wrap all info up
      if (s.startsWith("" + getClass()) || s.startsWith(getClass().toString()) || s.startsWith("de.businesscode.bcdui.logging.SqlToDatabaseLogger$LogRecord"))
        // TODO : is all this info needed, or do we only want specifics (compare to LogEvents captured by BcdStatementWrapper in EE project)
        return "SqlToDatabaseLogger.LogRecord <<jdbcMethod: " + jdbcMethod + ">, <sql: " + sql + ">, <stamp: " + stamp
            + ">, <durationMs: " + durationMs + ">, <rowsAffected: " + rowsAffected + ">, <sessionId: " + sessionId
            + ">, <pageHash: " + pageHash + ">, <requestHash: " + requestHash + ">>";
      return s;
    }
  }

  private final static String TPL_INSERT_STMT =
      "#set($b = $bindings.bcd_log_sql)" +
          " INSERT INTO $b.plainTableName (" +
          "   $b.logTime-" +
          ",  $b.durationMs-" +
          ",  $b.rowsAffected-" +
          ",  $b.jdbcMethod-" +
          ",  $b.sql-" +
          ",  $b.sessionId-" +
          ",  $b.pageHash-" +
          ",  $b.requestHash-" +
          ") VALUES (?,?,?,?,?,?,?,?)";


  protected SqlToDatabaseLogger() {
    super("bcd_log_sql",
        BareConfiguration.getInstance().getConfigurationParameter(PARAM_QUEUE_SIZE, DEFAULT_QUEUE_SIZE),
        BareConfiguration.getInstance().getConfigurationParameter(PARAM_QUEUE_SLEEP_MS, DEFAULT_QUEUE_SLEEP_MS));
  }

  private static SingletonHolder<SqlToDatabaseLogger> holder = new SingletonHolder<SqlToDatabaseLogger>() {
    @Override
    protected SqlToDatabaseLogger createInstance() {
      return new SqlToDatabaseLogger();
    }
  };

  public static SqlToDatabaseLogger getInstance() {
    return holder.get();
  }

  @Override
  protected String getSqlTemplate() {
    return new SQLEngine().transform(TPL_INSERT_STMT);
  }

  /**
   * processes given collection of type to dimensional object array to be consumed by batch SQL
   *
   * @param records
   * @return
   */
  @Override
  protected Object[][] convertData(Collection<SqlToDatabaseLogger.LogRecord> records) {
    Object[][] data = new Object[records.size()][];

    int cnt=0;
    for(SqlToDatabaseLogger.LogRecord record: records){
      data[cnt++] = new Object[]{
        new Timestamp(record.stamp.getTime()),
        record.durationMs,
        record.rowsAffected,
        record.jdbcMethod,
        record.sql,
        record.sessionId,
        record.pageHash,
        record.requestHash
      };

    }

    return data;
  }
}
