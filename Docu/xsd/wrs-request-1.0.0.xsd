<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2010-2022 BusinessCode GmbH, Germany

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           elementFormDefault="qualified" attributeFormDefault="unqualified"
           targetNamespace="http://www.businesscode.de/schema/bcdui/wrs-request-1.0.0"
           xmlns:tns="http://www.businesscode.de/schema/bcdui/wrs-request-1.0.0"
           xmlns:bnd="http://www.businesscode.de/schema/bcdui/bindings-1.0.0"
           xmlns:calc="http://www.businesscode.de/schema/bcdui/calc-1.0.0"
           xmlns:f="http://www.businesscode.de/schema/bcdui/filter-1.0.0">
  <xs:annotation>
    <xs:documentation>
      Documentation on BCD-UI's wrs request for data retrieval.
    </xs:documentation>
  </xs:annotation>

  <xs:import namespace="http://www.businesscode.de/schema/bcdui/filter-1.0.0"/>
  <xs:import namespace="http://www.businesscode.de/schema/bcdui/bindings-1.0.0"/>
  <xs:import namespace="http://www.businesscode.de/schema/bcdui/calc-1.0.0"/>

  <xs:element name="WrsRequest" type="tns:TypeWrsRequest">
    <xs:annotation><xs:documentation>A request to the standard WrsServlet for a wrs:Wrs document</xs:documentation></xs:annotation>
  </xs:element>

  <xs:element name="WrsService">
    <xs:annotation><xs:documentation>
      A request addressing a custom service instead of the default WrsServlet.
      Such a service returns a Wrs and is a custom class registered in web.xml for init param "UserServices".
      This can have any xml content which is understood by your service class.
    </xs:documentation></xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:any minOccurs="0" processContents="skip">
          <xs:annotation><xs:documentation>This can have any xml content which is understood by your service class. 2</xs:documentation></xs:annotation>
        </xs:any>
      </xs:sequence>
      <xs:attribute name="serviceName">
        <xs:annotation><xs:documentation>Registered service to be used</xs:documentation></xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="TypeWrsRequest">
    <xs:sequence>
      <xs:element name="Header" type="tns:TypeHeader" minOccurs="0">
      </xs:element>

      <!-- CTE -->
      <xs:element name="With" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="Cte" minOccurs="0" maxOccurs="999">
              <xs:complexType>
                <xs:group ref="tns:GroupFullSelect"/>
                <xs:attribute name="alias" type="bnd:AttrTypeSimpleId" use="required">
                  <xs:annotation><xs:documentation>Use for wrq:Ref/@alias and its bRefs like alias.bRefName</xs:documentation></xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <!-- Full Select -->
      <xs:group ref="tns:GroupFullSelect" minOccurs="0">
      </xs:group>
    </xs:sequence>
    <xs:attribute name="url" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation>Custom WrsServlet path relatively to contextPath</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:complexType name="TypeHeader">
    <xs:sequence>
      <xs:choice minOccurs="0">
        <xs:element name="CsvExport" type="tns:TypeExportCsv">
          <xs:annotation><xs:documentation>Extra information about the cvs format. Make sure to send the request the cvs export servlet</xs:documentation></xs:annotation>
        </xs:element>
        <xs:element name="SylkExport" type="tns:TypeExport">
          <xs:annotation><xs:documentation>Make sure to send the request the sylk export servlet</xs:documentation></xs:annotation>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <!-- A full select is SELECT [UNION SELECT]* -->
  <xs:group name="GroupFullSelect">
    <xs:sequence>
      <xs:element name="Select" type="tns:TypeSelect">
      </xs:element>
      <xs:sequence minOccurs="0" maxOccurs="999">
        <xs:choice>
          <xs:element name="Union"        type="xs:string" fixed=""/>
          <xs:element name="UnionAll"     type="xs:string" fixed=""/>
          <xs:element name="Except"       type="xs:string" fixed=""/>
          <xs:element name="ExceptAll"    type="xs:string" fixed=""/>
          <xs:element name="Intersect"    type="xs:string" fixed=""/>
          <xs:element name="IntersectAll" type="xs:string" fixed=""/>
        </xs:choice>
        <xs:element name="Select" type="tns:TypeSelect">
        </xs:element>
      </xs:sequence>
    </xs:sequence>
  </xs:group>

  <xs:element name="Columns" type="tns:TypeSelectColumns">
    <xs:annotation><xs:documentation>List of requested wrs:Wrs columns.</xs:documentation></xs:annotation>
  </xs:element>

  <xs:complexType name="TypeSelect">
    <xs:sequence>
      <xs:element name="TopNDimMembers" type="tns:TopNDimMembers" minOccurs="0">
        <xs:annotation><xs:documentation>
          Requires BCD-UI Enterprise-Edition.
          Allow top-n restriction in terms of dimensions and a measures.
        </xs:documentation></xs:annotation>
      </xs:element>
      <xs:element ref="tns:Columns" minOccurs="0">
        <xs:annotation><xs:documentation>
          List of requested wrs:Wrs columns. If empty, all BindingItems of the BindingSet are returned. BindingSet must allow this via @allowSelectAllColumns.
        </xs:documentation></xs:annotation>
      </xs:element>
      <xs:element name="From">
        <xs:annotation><xs:documentation>Source of data. Can be a full wrq:Select (SELECTs with SET operators), a wrq:BindingSet, a wrq:Ref and a join clause.</xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:group ref="tns:GroupTableReference"></xs:group>
        </xs:complexType>
      </xs:element>
      <xs:element ref="f:Filter" minOccurs="0">
        <xs:annotation><xs:documentation>Restrict the resultset.</xs:documentation></xs:annotation>
      </xs:element>
      <xs:element name="Grouping" type="tns:TypeGrouping" minOccurs="0"/>
      <xs:element name="Having"   type="f:TypeFilter"     minOccurs="0">
        <xs:annotation><xs:documentation>
          Allows the same f:* children as f:Filter. Ignore case @ic is only allowed for dimensions.
          For non-dimensions reuses the aggr if the bindingItem also appears in the SELECT clause (last the occurance, if it appears multiple times),
          otherwise it falls back to aggregation defaults SUM for numeric else MAX.
        </xs:documentation></xs:annotation>
      </xs:element>
      <xs:element name="Ordering" type="tns:TypeOrdering" minOccurs="0"/>
      <xs:element name="Vdms" type="tns:TypeVdms" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Virtual dimension members defined here allow for collapsing dimension members (i.e. actual values of a dimension) into an artificial value.
            For example collapse countries "NL", "BE", and "LX" into "BeNeLux".
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="id" type="xs:ID"/>
    <xs:attribute name="rowStart" type="xs:int" use="optional">
      <xs:annotation>
        <xs:documentation>
          Requires Enterprise-Edition. First row == 1.
          If (@rowStart is not given or =0) and @rowEnd>0, a wrs:MaxRowsExceeded footer will be appended if not all rows are read. That footer will not be written, if @rowStart > 1.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowEnd" type="xs:int">
      <xs:annotation>
        <xs:documentation>If set to 0 or less than rowStart, and empty Wrs with a filled wrq:Header will be returned, no SQL will be performed.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="alias" type="bnd:AttrTypeSimpleId" use="optional">
      <xs:annotation><xs:documentation>Alias prefix for bRefs like alias.bRefName</xs:documentation></xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="TopNDimMembers">
    <xs:sequence>
      <xs:element name="TopNDimMember" minOccurs="0" maxOccurs="999">
        <xs:annotation><xs:documentation>
          A top-n restriction, for example show only those results, where ctr,center: sum(weight) is above the top 10.
        </xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="LevelRef" maxOccurs="999">
              <xs:annotation><xs:documentation>Dimension regarding this top-n restriction is to be evaluated.</xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:attribute name="bRef" type="xs:NCName" use="optional">
                  <xs:annotation><xs:documentation>Reference to a dimension of the query.</xs:documentation></xs:annotation>
                </xs:attribute>
                <xs:attribute name="partition" type="xs:boolean" default="false">
                  <xs:annotation><xs:documentation>
                    If true, the top-n values are partitioned by this level.
                  </xs:documentation></xs:annotation>
                </xs:attribute>
                <xs:attribute name="caption" type="xs:string">
                  <xs:annotation><xs:documentation>Human readable caption.</xs:documentation></xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="Measure">
              <xs:annotation><xs:documentation>Measure regarding this top-n restriction is to be evaluated.</xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="Calc" type="tns:TypeCalc">
                    <xs:annotation><xs:documentation>
                      Definition of a server-calc. A server-calc is executed on the server and returned as a single value
                    </xs:documentation></xs:annotation>
                  </xs:element>
                </xs:sequence>
                <xs:attribute name="id"/>
                <xs:attribute name="caption"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="n" type="xs:nonNegativeInteger">
            <xs:annotation><xs:documentation>The 'n' of the top-n restriction.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="tb">
            <xs:annotation><xs:documentation>Whether top or bottom.</xs:documentation></xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="top"/>
                <xs:enumeration value="bottom"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="TypeSelectColumns">
    <xs:sequence maxOccurs="999" minOccurs="0">
      <xs:element name="C" type="tns:TypeSelectColumn">
        <xs:annotation><xs:documentation>
          A plain or virtual BindingItem.
          You may add any additional attribute, it will be carried over to the corresponding wrs:Header/wrs:Columns/wrs:C.
          If you overwrite one of the attributes of bnd:BindingSet/bnd:C, your attribute value will overwrite the server value (as long as it is not security relevant).
        </xs:documentation></xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>


  <xs:complexType name="TypeColumn">
    <xs:sequence>
      <xs:element name="Calc" type="tns:TypeCalc" minOccurs="0">
        <xs:annotation><xs:documentation>
          This is a server-calculation if wrq:Calc is given. @bRef is then not referring to a BindingItem within a BindingSet,
          but the id of the new VirtualBindingItem created here based on the calc.
        </xs:documentation></xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="bRef" type="xs:string" use="optional">
      <xs:annotation><xs:documentation>
        Referenced BindingItem, may be preceded by the table reference alias. Mandatory unless wrq:Calc is our child, then provide an @id.
      </xs:documentation></xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- Type of wrq:A elements -->
  <xs:complexType name="TypeColumnAttribute">
    <xs:sequence>
      <xs:element name="Calc" type="tns:TypeCalc" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="bRef" type="xs:NCName" use="optional">
      <xs:annotation><xs:documentation>
        Referenced BindingItem, may be preceded by the table reference alias. Mandatory unless wrq:Calc is our child.
      </xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:NCName" use="required"/>
    <xs:attribute name="skipForTotals" type="xs:boolean" use="optional" default="false">
      <xs:annotation><xs:documentation>
        Some wra:A like captions of a dimension do not make sense for (sub)totals, i.e. when their parent wrs:C does not have a unique value.
        With @skipForTotals, they can also be nulled-out for sub-totals of their parent wrs:C.
      </xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="bnd:RequestOverwritable">
      <xs:annotation><xs:documentation>
        These attributes default to the values of the BindingSet, but can be overwritten in the request.
      </xs:documentation></xs:annotation>
    </xs:attributeGroup>
  </xs:complexType>

  <xs:complexType name="TypeSelectColumn">
    <xs:complexContent>
      <xs:extension base="tns:TypeColumn">
        <xs:sequence maxOccurs="999" minOccurs="0">
          <xs:element name="A" type="tns:TypeColumnAttribute" minOccurs="0" maxOccurs="999">
            <xs:annotation><xs:documentation>
              In SQL behaves like a normal wrq:C but becomes an attribute on its parent wrs:C instead of a wrs:C of its own.
            </xs:documentation></xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="escapeXml" type="xs:boolean" default="true" use="optional">
          <xs:annotation><xs:documentation>
            If false, data read from VARCHAR or CLOB can be delivered as "inline XML", i.e. it will be part of the returning Wrs/Data/R/C instead of
            being returned as an escaped string. True, is default.
          </xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute name="alias" type="bnd:AttrTypeSimpleId" use="optional">
          <xs:annotation><xs:documentation>
            Alias to address the column under a different name, useful in cases like sub selects of joins.
          </xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="bnd:RequestOverwritable">
          <xs:annotation><xs:documentation>
            These attributes default to the values of the BindingSet, but can be overwritten in the request.
          </xs:documentation></xs:annotation>
        </xs:attributeGroup>
        <xs:anyAttribute processContents="lax">
          <xs:annotation><xs:documentation>
            Any given attribute will be copied to the Wrs as is.
            If it is one of the attributes of bnd:C, it overwrites the value given at the server.
          </xs:documentation></xs:annotation>
        </xs:anyAttribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="TypeSQLAggregations">
    <xs:restriction base="xs:string">
      <xs:enumeration value="sum"></xs:enumeration>
      <xs:enumeration value="min"></xs:enumeration>
      <xs:enumeration value="max"></xs:enumeration>
      <xs:enumeration value="avg"></xs:enumeration>
      <xs:enumeration value="count"></xs:enumeration>
      <xs:enumeration value="GROUPING">
        <xs:annotation><xs:documentation>
          Flag 0/1 which indicates whether the current row is a (sub)-total in respect of this BindingItem.
          For Redshift and MySql (only) this is a simple null test.
        </xs:documentation></xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="none">
        <xs:annotation><xs:documentation>
          Explicitly suppress any aggregation, including defaults.
          Use case sample: Rely on the aggregation being done in the column expression of the BindingItem.
        </xs:documentation></xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- We make this a global element in our namespace as we refer to it for example from cube schema. -->
  <xs:element name="BindingSet" type="tns:TypeBindingSet"/>

  <!-- wrq:From can be a full wrq:Select (SELECTs with SET operators), a wrq:BindingSet, a wrq:Ref and a join clause -->
  <xs:group name="GroupTableReference">
    <xs:sequence>
      <!-- Table reference -->
      <xs:choice>
        <xs:group ref="tns:GroupFullSelect"></xs:group>
        <xs:element ref="tns:BindingSet">
          <xs:annotation><xs:documentation>Name of source BindingSet</xs:documentation></xs:annotation>
        </xs:element>
        <xs:element name="CteRef" type="tns:TypeCteRef">
          <xs:annotation><xs:documentation>References a wrq:Cte/@alias</xs:documentation></xs:annotation>
        </xs:element>
      </xs:choice>
      <!-- Join -->
      <xs:choice minOccurs="0" maxOccurs="999">
        <xs:element name="InnerJoin"      type="tns:TypeJoin"/>
        <xs:element name="FullOuterJoin"  type="tns:TypeJoin"/>
        <xs:element name="LeftOuterJoin"  type="tns:TypeJoin"/>
        <xs:element name="RightOuterJoin" type="tns:TypeJoin"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <!-- Referencing a bnd:BindingSet and defining an optional alias -->
  <xs:complexType name="TypeBindingSet">
    <xs:simpleContent>
      <xs:extension base="xs:NCName">
        <xs:attribute name="alias" type="bnd:AttrTypeSimpleId" use="optional">
          <xs:annotation><xs:documentation>Can be referenced in bRefs like alias.bRefName and in wrq:Ref/@alias</xs:documentation></xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <!-- Referencing a Cte -->
  <xs:complexType name="TypeCteRef">
    <xs:simpleContent>
      <xs:extension base="bnd:AttrTypeSimpleId">
        <xs:attribute name="alias" type="bnd:AttrTypeSimpleId" use="optional">
          <xs:annotation><xs:documentation>References a wrq:Cte/@alias</xs:documentation></xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <!-- A table reference with a join clause -->
  <xs:complexType name="TypeJoin">
    <xs:sequence>
      <xs:group ref="tns:GroupTableReference"></xs:group>
      <xs:group ref="tns:GroupJoinFilter" maxOccurs="999"></xs:group>
    </xs:sequence>
  </xs:complexType>

  <!-- Join condition. Links values of a left part of a join to the one of the right part -->
  <xs:complexType name="TypeOn">
    <xs:attribute name="left" type="xs:NCName" use="required">
      <xs:annotation><xs:documentation>Left bRef with alias</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="right" type="xs:NCName" use="required">
      <xs:annotation><xs:documentation>Right bRef with alias</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="op" type="f:TypeSQLOperators" use="optional" default="=">
    </xs:attribute>
  </xs:complexType>

  <!-- A recursive wrq:And/wrq:Or connected list of wrq:On clauses -->
  <xs:group name="GroupJoinFilter">
    <xs:choice>
      <xs:element name="And" minOccurs="0" maxOccurs="999">
        <xs:complexType>
          <xs:group ref="tns:GroupJoinFilter"></xs:group>
        </xs:complexType>
      </xs:element>
      <xs:element name="Or" minOccurs="0" maxOccurs="999">
        <xs:complexType>
          <xs:group ref="tns:GroupJoinFilter"></xs:group>
        </xs:complexType>
      </xs:element>
      <xs:element name="On" type="tns:TypeOn" minOccurs="0" maxOccurs="999"/>
    </xs:choice>
  </xs:group>


  <!-- wrq:GroupBy clause -->
  <xs:complexType name="TypeGrouping">
    <xs:sequence minOccurs="0" maxOccurs="999">
      <xs:element name="C" type="tns:TypeColumn" minOccurs="0" maxOccurs="999">
        <xs:annotation><xs:documentation>
          BindingItem to be used for grouping. If used on combination with wrq:GroupingSets, they become implicit part of each wrq:GroupingSets/wrq:Set.
        </xs:documentation></xs:annotation>
      </xs:element>
      <xs:element name="GroupingSets" type="tns:TypeGroupingSets" minOccurs="0" maxOccurs="999">
        <xs:annotation><xs:documentation>
          Allows creation of aggregations on different levels. if multiple wrq:GroupingSets are present, each combination of their sets is created.
        </xs:documentation></xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="TypeGroupingSets">
    <xs:sequence minOccurs="0" maxOccurs="999">
      <xs:element name="Set">
        <xs:annotation><xs:documentation>Each set defines a different set of grouping-BIs</xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="C" type="tns:TypeColumn" minOccurs="0" maxOccurs="999">
              <xs:annotation><xs:documentation>BindingItem to be used for grouping in this set.</xs:documentation></xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="TypeOrdering">
    <xs:sequence minOccurs="0" maxOccurs="999">
      <xs:element name="C">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="tns:TypeColumn">
              <xs:attribute name="order" type="tns:TypeOrderingAttr" use="optional"/>
              <xs:attribute name="aggr" type="tns:TypeSQLAggregations" use="optional">
                <xs:annotation><xs:documentation>
                  If not given, BindingSet/C/@aggr is used, if also not given, MAX() is used for VARCHAR and DATE, SUM() for all others.
                  All of this is ignored, if a wrq:Calc child (i.e. a server-calc) is provided.
                </xs:documentation></xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:simpleType name="TypeOrderingAttr">
    <xs:restriction base="xs:string">
      <xs:enumeration value="desc"/>
      <xs:enumeration value="asc"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="TypeVdms">
    <xs:sequence minOccurs="0" maxOccurs="999">
      <xs:element name="Vdm" minOccurs="0" maxOccurs="999">
        <xs:annotation><xs:documentation>
          Defines which database values of a @bRef should be collapsed into what values.
        </xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="VdmMap" minOccurs="0" maxOccurs="999">
              <xs:annotation><xs:documentation>
                Collapses all values from @from to a new value given by @to.
              </xs:documentation></xs:annotation>
              <xs:complexType>
                <xs:attribute name="from" type="xs:string" use="required">
                  <xs:annotation><xs:documentation>
                    Semicolon (;) separated list of values to collapse into @to.
                  </xs:documentation></xs:annotation>
                </xs:attribute>
                <xs:attribute name="to" type="xs:string">
                  <xs:annotation><xs:documentation>
                    Value of the created virtual dimension member combining the values listed in @from.
                  </xs:documentation></xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <!-- Attributes from wrq:Vdm -->
          <xs:attribute name="bRef" type="xs:NCName">
            <xs:annotation><xs:documentation>
              BindingItem to act on.
            </xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="rest" type="xs:string" use="optional">
            <xs:annotation><xs:documentation>
              Value representing all values not mapped in a wrq:VdmMap.
            </xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="TypeExportCsv">
    <xs:complexContent>
      <xs:extension base="tns:TypeExport">
        <xs:attribute name="separator" type="xs:string" default=";" />
        <xs:attribute name="quoteCharacter" type="xs:string" default="" />
        <xs:attribute name="header" default="none">
          <xs:annotation><xs:documentation>Define how the optional header line should look like.</xs:documentation></xs:annotation>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="none" /><!-- no header -->
              <xs:enumeration value="id" /><!-- bindingItem id -->
              <xs:enumeration value="caption" /><!-- bindingItem caption -->
              <xs:enumeration value="raw" /><!-- DB column names -->
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="TypeExport">
    <xs:sequence minOccurs="0" maxOccurs="1">
      <xs:element name="AddHeaderInfo" type="xs:string">
        <xs:annotation><xs:documentation>Additional information which is listed above the actual exported column headers</xs:documentation></xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <!--
    Definition of server-side calculations
    -->
  <xs:complexType name="TypeCalc">
    <xs:choice>
      <xs:element ref="tns:CalculatedValue"/>
      <xs:element ref="tns:AnalyticFct"/>
    </xs:choice>
    <xs:attribute name="type-name"    type="bnd:ColumnTypeName" />
    <xs:attribute name="scale"        type="xs:integer"/>
    <xs:attribute name="signed"       type="xs:boolean" />
    <xs:attribute name="unit"         type="xs:string" />
  </xs:complexType>

  <!--
    Analytical functions
    -->
  <xs:element name="AnalyticFct" type="tns:TypeAnalyticFct" abstract="true"/>
  <xs:element name="SumOver"    type="tns:TypeAnalyticFct" substitutionGroup="tns:AnalyticFct"/>
  <xs:element name="CountOver"  type="tns:TypeAnalyticFct" substitutionGroup="tns:AnalyticFct"/>
  <xs:element name="LeadOver"   type="tns:TypeAnalyticFct" substitutionGroup="tns:AnalyticFct"/>

  <xs:complexType name="TypeAnalyticFct">
    <xs:sequence>
      <xs:element ref="tns:CalculatedValue" minOccurs="1" maxOccurs="3"/>
      <xs:element name="PartitionBy" type="tns:MultiOperatorType" minOccurs="0">
        <xs:annotation><xs:documentation>Requires BCD-UI Enterprise-Edition</xs:documentation></xs:annotation>
      </xs:element>
      <xs:element name="OrderBy" minOccurs="0">
        <xs:annotation><xs:documentation>Requires BCD-UI Enterprise-Edition</xs:documentation></xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="tns:MultiOperatorType">
              <xs:attribute name="order" type="tns:TypeOrderingAttr" use="optional"/>
              <xs:attribute name="nullsOrder" use="optional">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:enumeration value="nullsFirst"/>
                    <xs:enumeration value="nullsLast"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <!--
    Values or values derived from a calculation
   -->
  <xs:element name="CalculatedValue" type="tns:CalculatedValueType" abstract="true"/>
  <xs:complexType name="CalculatedValueType"/>

  <xs:element name="Value" substitutionGroup="tns:CalculatedValue">
    <xs:annotation><xs:documentation>A user given constant value</xs:documentation></xs:annotation>
    <xs:complexType>
      <xs:complexContent mixed="true">
        <xs:extension base="tns:CalculatedValueType"/>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <xs:element name="ValueRef" substitutionGroup="tns:CalculatedValue">
    <xs:annotation><xs:documentation>References a BindingItem from a BindingSet.</xs:documentation></xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="tns:CalculatedValueType">
          <xs:attribute name="idRef" type="xs:NCName" use="required">
            <xs:annotation><xs:documentation>Id of the referenced BindingItem.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="aggr" type="tns:TypeSQLAggregations" use="optional">
            <xs:annotation><xs:documentation>
              It is preferred to use wrq: aggregators surrounding the ValueRef instead of using this attribute. If given, the wrq: aggregator is used and this ignored.
              If non is given, SUM() is used in all cases, note: that default fails for non-numeric values.
            </xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <!--
    Operator types, providing as a result themsevles a value
   -->
  <xs:complexType name="MultiOperatorType">
    <xs:complexContent>
      <xs:extension base="tns:CalculatedValueType">
        <xs:sequence>
          <xs:element ref="tns:CalculatedValue" minOccurs="1" maxOccurs="999"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="BinaryOperatorType">
    <xs:complexContent>
      <xs:extension base="tns:CalculatedValueType">
        <xs:sequence>
          <xs:element ref="tns:CalculatedValue"/>
          <xs:element ref="tns:CalculatedValue"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="UnaryOperatorType">
    <xs:complexContent>
      <xs:extension base="tns:CalculatedValueType">
        <xs:sequence>
          <xs:element ref="tns:CalculatedValue"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- 1..n arguments -->
  <xs:element name="Add" type="tns:MultiOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Mul" type="tns:MultiOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Sub" type="tns:MultiOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Concat" substitutionGroup="tns:CalculatedValue">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="tns:MultiOperatorType">
          <xs:attribute name="separator" type="xs:string">
            <xs:annotation><xs:documentation>If given, this string separates to elements. Conside using &amp;#xE0F0;.</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <!-- 2 arguments -->
  <xs:element name="Div" type="tns:BinaryOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Mod" type="tns:BinaryOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Min" type="tns:BinaryOperatorType" substitutionGroup="tns:CalculatedValue"/>

  <!-- One argument aggregators -->
  <xs:element name="Sum" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Max" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Avg" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Count" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="Distinct" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue"/>
  <xs:element name="CountDistinct" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue"/>

  <!-- One argument operators -->
  <xs:element name="Niz" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue">
    <xs:annotation><xs:documentation>NULL if zero.</xs:documentation></xs:annotation>
  </xs:element>
  <xs:element name="MakeNull" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue">
    <xs:annotation><xs:documentation>Effectively makes its content null. Useful when a wrq:ValueRef is need but should be substituted by null.</xs:documentation></xs:annotation>
  </xs:element>
  <xs:element name="CastAsVarchar" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue">
    <xs:annotation><xs:documentation>Surrounds its content with an explicit cast to VARCHAR.</xs:documentation></xs:annotation>
  </xs:element>
  <xs:element name="CastAsNumeric" type="tns:UnaryOperatorType" substitutionGroup="tns:CalculatedValue">
    <xs:annotation><xs:documentation>Surrounds its content with an explicit cast to DECIMAL.</xs:documentation></xs:annotation>
  </xs:element>
  <xs:element name="CastAsBRef" substitutionGroup="tns:CalculatedValue">
    <xs:annotation><xs:documentation>Surrounds its content with an explicit cast to the type of the given bRef.</xs:documentation></xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="tns:UnaryOperatorType">
          <xs:attribute name="bRef" use="required"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

</xs:schema>
