<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../_generator/doc.xslt" media="screen" ?>
<!--
  Copyright 2010-2017 BusinessCode GmbH, Germany

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<doc:Doc title="XSLT library" xmlns:doc="http://www.businesscode.de/schema/bcdui/doc-1.1.0">
  <doc:Chapter type="overview" title="Overview">
    <doc:Body>
      The XSLT library contains a set of generic XSLTs often required tasks many of the XSLTs perform operations on Wrs.
      In several cases, the final stylesheets are generated in the background for optimal performance n the fly.
      These XSLT may be used in a chain a model wrapper or a model updater.
    </doc:Body>

    <doc:SubChapter title="Data transformation">
      <doc:Body>
        <dl>
          <dt>Column filter and order</dt>
          <dd>Only include listed columns the order given by the parameter. (orderCols.xslt)</dd>
          <dt>Pagination</dt>
          <dd>limit and access data with a given page size</dd>
          <dt>Join</dt>
          <dd>Join two WRS over data keys, supports inner, left outer and cross joins.</dd>
          <dt>Transpose grouping</dt>
          <dd>Transpose a dimension column into a row (i.e. it becomes a column dimension). All data cells are adjusted accordingly.</dd>
          <dt>Pivots</dt>
          <dd>Takes a subset of the dimensions and moves then into a top-row and adjusts the measures accordingly.</dd>
          <dt>Grouping</dt>
          <dd>Create aggregate rows as roll-ups, useful for totals.</dd>
        </dl>
        Later versions of BCD-UI are likely to contain sort rows by content, filter rows on content.
      </doc:Body>
    </doc:SubChapter>

    <doc:SubChapter title="Data set manipulation">
      <doc:Body>
        <dl>
          <dt>Insert empty rows</dt>
          <dd>Insert n consecutive empty rows (with new row ids), auto-fill in mandatory columns if they only have on possible value.</dd>
          <dt>Duplicate rows</dt>
          <dd>Duplicate a range of rows (with new row ids).</dd>
          <dt>Delete</dt>
          <dd>Delete (=mark as deleted) a range of rows.</dd>
          <dt>Restore</dt>
          <dd>Restore a range of rows, marked as deleted.</dd>
          <dt>Merge</dt>
          <dd>Merge one WRS into another. Existing rows (same row-id) will be modified, rows with new row-ids will be inserted (marked as inserted).</dd>
          <dt>Validate</dt>
          <dd>Validates the data of the input WRS against the WRS header. Adds a validation-resule WRS into the input WRS' header</dd>
          <dt>Number formatting</dt>
          <dd>Formats the data according to their format defined in the WRS header (scale, unit, later also i18n).</dd>
        </dl>

        <p/>
        Example: Inserting or deleting rows in Javascript. Assuming you got a model with id "wrs" with some rows in it.
        <pre><![CDATA[bcdui.wrs.wrsUtil.insertRow({model: bcdui.factory.objectRegistry.getObject("wrs"), rowStartPos: 2, rowEndPos: 3});]]></pre>
        <pre><![CDATA[bcdui.wrs.wrsUtil.deleteRows({model: bcdui.factory.objectRegistry.getObject("wrs"), rowStartPos: 2, rowEndPos: 3});]]></pre>

      </doc:Body>
    </doc:SubChapter>

    <doc:SubChapter title="Transformation into none-WRS">
      <doc:Body>
        These XSLT translate between a simplified clipboard format and WRS.
        The in/output is <div><![CDATA[<Wrs xmlns:wrs=".."><Data><R><D/>..<D/></R><R><D/>..<D/></R>..</Data></Wrs>]]></div>without any header.
        A js function is responsible for transforming csv from clipboard from and into the simplified format.
        <dl>
          <dt>Copy</dt>
          <dd>Puts the content of a WRS in clip board format into the clipboard.</dd>
          <dt>Paste/Paste as new</dt>
          <dd>Pasts the content of the clipboard given in the clip board format to a row in a given WRS.</dd>
        </dl>
        Later versions of BCD-UI are likely to support transformations to CSV, Sylk and Excel XML
      </doc:Body>
    </doc:SubChapter>
    
    <doc:SubChapter title="XSLT parametrisation">
      <doc:Body>
        All wrs modifying XSLT get their parameters via an XML of type xmlns:xp="http://www.businesscode.de/schema/bcdui/xsltParams-1.0.0".
        Basically there is an element defined for each of the stylesheets with the same name which holds the parameters.
        If the parameter model contains multiple elements of the same type, for example to support multiple chains or switch between settings,
        an optional attribute paramSetId allows to select a specific one.
        <doc:xml>
          <xp:XSLTParameters
            xmlns:xp="http://www.businesscode.de/schema/bcdui/xsltParams-1.0.0"
            xmlns:wrs="http://www.businesscode.de/schema/bcdui/wrs-1.0.0">

            <xp:Paginate>
              <xp:PageSize>6</xp:PageSize>
              <xp:PageNumber>1</xp:PageNumber>
            </xp:Paginate>

            <xp:OrderCols>
              <wrs:Columns>
                <wrs:C id="CTR" pos="1" />
                <wrs:C id="LOW" pos="2" />
                <wrs:C id="COLOR" pos="3" />
              </wrs:Columns>
            </xp:OrderCols>

            <xp:OrderCols paramSetId="set2">
              <wrs:Columns>
                <wrs:C id="CW" pos="1" />
                <wrs:C id="HIGH" pos="2" />
                <wrs:C id="PNLOW" pos="3" />
              </wrs:Columns>
            </xp:OrderCols>
          </xp:XSLTParameters>
        </doc:xml>
        Above example shows three parameters, one for paginate.xslt and two for orderCols.xslt.
        Since there are two OrderCols elements, orderCols action has to get the parameter paramSetId=set2 to choose the second one.
        <pre><![CDATA[<b:modelWrapper id="mW" stylesheetUrl="../../bcdui/xslt/wrs/orderCols.xslt">
  <b:ref idRef="inputModel"/>
  <b:param name="paramModel"><b:model id="xsltParams" url="xsltParams.xml"/></b:param>
  <b:param name="paramSetId" value="set2"/>
</b:modelWrapper>]]></pre>
      </doc:Body>
    </doc:SubChapter>

    <doc:SubChapter title="HTML rendering">
      <doc:Body>
        BCDUI offers you some HTML renderer which allow you easy visualization of data.
        While the html builder renders data in a flat table format (also supporting cube-like visualization
        with column and row spanning), the tree builder supports a tree-like structure with branches and leafs
        which can expand and collapse.
        <dl>
          <dt>HTML builder</dt>
          <dd>Rendering a table out of the data in "myDataModel" model in a container div "myDiv" can
          be done like this:
            <pre><![CDATA[bcdui.factory.createRenderer({
  targetHTML: "myDiv"
, inputModel: bcdui.factory.objectRegistry.getObject("myDataModel")
, url: "../../bcdui/xslt/renderer/htmlBuilder.xslt"});]]></pre>
            <p/>
            <img src="plainView.png"/>
          </dd>
          <dd>The HTML Builder got several parameters to modify spanning and sorting options.
            Turning off default row sorting:
            <pre><![CDATA[bcdui.factory.createRenderer({
    targetHTML: "myDiv"
  , inputModel: bcdui.factory.objectRegistry.getObject("myDataModel")
  , url: "../../bcdui/xslt/renderer/htmlBuilder.xslt"
  , parameters:{sortRows: false}
});]]></pre>
            Turning on rowspanning (like the cube does):
            <pre><![CDATA[bcdui.factory.createRenderer({
    targetHTML: "myDiv"
  , inputModel: bcdui.factory.objectRegistry.getObject("myDataModel")
  , url: "../../bcdui/xslt/renderer/htmlBuilder.xslt"
  , parameters:{makeRowSpan: true}
});]]></pre>
            <p/>
            <img src="cubeView.png"/>
          </dd>
          <dt>HTML tree builder</dt>
          <dd>Rendering data as a tree can be achieved with the following renderer chain for example:
            <pre><![CDATA[bcdui.factory.createModel({id: "tree_chain", url: "tree_chain.xml"});
bcdui.factory.createRenderer({
  , targetHtml: "myDiv"
  , chain: "tree_chain"
  , dataProviders: ["myDataModel"]
  , parameters: { number_of_levels: "3" }
});]]></pre>
            with tree_chain.xml as follows:
            <doc:xml>
              <Chain xmlns="http://www.businesscode.de/schema/bcdui/chain-1.0.0" xmlns:xi="http://www.w3.org/2001/XInclude">
                <Phase name="rendering">
                  <Stylesheet url="../../bcdui/js/component/treeView/generateTree.xslt" />
                  <Stylesheet url="../../bcdui/js/component/treeView/rendering.xslt" />
                </Phase>
              </Chain>
            </doc:xml>
          
            <p/>
            <img src="treeView.png"/>
          </dd>
        </dl>
      </doc:Body>
    </doc:SubChapter>

    <doc:SubChapter title="String Utilites">
      <doc:Body>
        Common string operations which do not come automatically with XSLT-1.0 are provided via string utility templates:
        <dl>
          <dt>printRows</dt><dd>prints a multi-line string with an indent row by row</dd>
          <dt>left-trim</dt><dd>cuts of whitespace from string start</dd>
          <dt>right-trim</dt><dd>cuts of whitespace from string end</dd>
          <dt>trim</dt><dd>cuts of whitespace from string start and end</dd>
          <dt>stringRepeater</dt><dd>repeats a given string n-times</dd>
          <dt>lastIndexOf</dt><dd>Finds the last occurrence of a character c in a string s</dd>
          <dt>replaceString</dt><dd>replace substring s1 with substring s2 in string s</dd>
          <dt>tokenize</dt><dd>splits up a delimiter separated string and returns a node set of elements</dd>
          <dt>nthToken</dt><dd>Gets the n-th token starting at 1 of a delimiter separated string</dd>
        </dl>
        <p/>
        Example: Typical xslt file header to work with string utilities
        <pre><![CDATA[<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:exslt="http://exslt.org/common"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt"
    exclude-result-prefixes="exslt msxsl">
  
    <xsl:import href="../../../xslt/stringUtil.xslt"/>
  
    <msxsl:script language="JScript" implements-prefix="exslt">this['node-set']= function (x) { return x; }</msxsl:script>
  
    <xsl:output method="xml" version="1.0" encoding="UTF-8"  indent="no" />
  </xsl:stylesheet>
]]></pre>

        <p/>
        Example: Tokenizing a space separated string and do something with each token. 
        <pre><![CDATA[<xsl:variable name="myString">This is a test</xsl:variable>

<!-- split up the string -->
<xsl:variable name="myStringTokens">
  <xsl:call-template name="tokenize">
    <xsl:with-param name="string" select="$myString" />
    <xsl:with-param name="delimiter" select="' '" />
  </xsl:call-template>
</xsl:variable>
  
<!-- build a nodeset -->
<xsl:variable name="myNodes" select="exslt:node-set($myStringTokens)" />

<!-- and run through the non empty single nodes and do something with each node -->
<xsl:for-each select="$myNodes/wrs:Wrs/wrs:Data/wrs:R[wrs:C[.!='']]">
  <xsl:call-template name="doSomething">
    <xsl:with-param name="item" select="."/>
  </xsl:call-template>
</xsl:for-each>]]></pre>
      </doc:Body>
    </doc:SubChapter>

    <doc:SubChapter title="Details">
      <doc:Body>
        <img src="xsltLibSchema.png"/>
      </doc:Body>
    </doc:SubChapter>

  </doc:Chapter>

</doc:Doc>