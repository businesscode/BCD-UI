[[Doc_designRationale]]
== Design rationales

=== Design rationales

This document collects design decisions


=== Documentation

* Documentation can be generated into pdf and HTML format
* Verbal documentation which is not attached to a single source (i.e. documentation beyond API) is kept in extra XML format separate from the sources in doc.xml files
* doc.xml files have a descriptive part, which describes the features of each component and an development part, which describes how to implement such a component
* doc.xml knowns example, featurelist and overview for feature description and api, extension and howItWorks for implementation description


=== Client side API

* Each component on client side of each granularity is represented by a 1:1 complete JS type with an js API and can be created programmatically
* JS calls use parameter mapping syntax as it scales better for many and optional parameters than parameter list syntax
* Larger components like Cube or ScoreCard have in addition a canonical XML representation making the majority of the features available to XML
* Extension points can be js callbacks and XSLT fragments
* Each component knows how to read the XML, several helper for that task are available
* Each component comes with a jsp wrapper, which acts only as a thin facade for HTML


=== Server data provider

* Data coming from the server is sent in a common WRS format. The WebRowSet format was extended and changed in some ways for easier handling
* The WrsRequest document is able to cover most data requests


=== Report stylesheet stack

A Wrs with dimensional columns can be displayed in

* A cube like manner as a table
* A tree like manner with plus


=== Widgets and components

Widgets are small graphical user interface objects

* The anchor of a widget its container element in the HTML DOM with the parameter attributes.
* The init() method of a widget gets a reference to this container element, the widget's init() does not care who created the container element
* init() reads its parameters, given as bcdParameterName attributes with the helper, which generated from the API doc.
* All methods of a widget are context free, i.e. no js object instance is create for a widget,if the container element is gone, the widget is gone.
* All init() parameters and all internal status are stored as attributes on the container
* There is a createXYZ() js api per widget to attach the parameters to the container, which is provided. This method has no further logic.
* There is a jsp tag per widget, using the js api, only having the logic of creating the container at its place in the DOM HTML.
* There is a xapi template per widget, only having the logic of creating the container and adding the parameters and calling init(). via bcdOnLoad
* Model listeners created by a widget remove themselfes if they are fired and the corresponding container HTML element is not longer present

Components are larger user interaction objects

* The anchor of a component and its definition is given as HTML elements and a configuration document
* The anchor is usually created by the component's factory XSLT
* This XSLT can be executed by a renderer, which itself is created in the component's JS factory or by embedding the XSLT in an host XSLT
* The JS factory can be called from JavaScript or via a thin jsp tag wrapper
* After rendering, the code in bcdOnLoad attribute is executed to further create the component
* The code of the component, for example the code belonging to an cube, is a static singleton. Only listeners and the definition document are created per component instance
* The component's data, like data of a grid editor or a cube, is stored in models and synced with the visual HTML representation
* Ids are derived from an optional idPrefix parameter (which itself is generated if not given), all models use that parameter with an appended maker, for example ${idPrefix}_Model

Sample

&lt;comp:chart id="chart_1" definitionModelRef="defModel"/&gt;:: Is put on a jsp page. It is a thin wrapper and does simply call
bcdui.component.chart.createChart():: in bcdui/component/chart/package.js, which could be called by JS directly. createChart() does create a renderer applying  `"/lib/bcdui/component/chart/chart.xslt"` 
the renderer:: creates the carrier HTML tag and does scan it for bcdOnLoad attribute to execute its content. This in turn is a call to
bcdui.component.chart.init():: in bcdui/component/chart/chart.js, which is creating the chart with the containing HTML element as the anchor. This anchor stores all configuration information, for example the id of the chart definition document.

|===
|||1) JSP Use the provided jsp tag:

|||
[source,javascript]
----

<comp:chart id="chart_1"
  definitionModelRef="chart_1_defModel"/>


----

||2) JS from scratch Call createChart() directly from JS with the values of course:|Generates:
||
[source,javascript]
----

bcdui.component.chart.createChart( {
    id:                  "chart_1",
    targetHTMLElementId: "chart_1_div",
    definitionModelRef:  "chart_1_defModel" }
);

----

|3) JS with HTML Or you can create the HTML element any other way:|This does apply a renderer, which creates the following HTML element:
|
[source,html]
----

<div id="chart_1"
  definitionmodelref="chart_1_defModel"
  style="width: 100%; height: 100%;">
</div>


----
|
[source,html]
----

<div id="chart_1" definitionmodelref="chart_1_defModel"
  style="width: 100%; height: 100%;"
  bcdOnLoad=
   "var id=bcdui.factory.objectRegistry.generateTemporaryId('chart_1');
    this.setAttribute('id',id); bcdui.component.chart.init( this );"
  >
</div>


----

|And call directly:|The renderer executes bcdOnLoad, calling:
|bcdui.component.chart.init( htmlElement )
|===
